# åª’ä½“ç´ å…»æ•™è‚²å¹³å° - æŠ€æœ¯æ–‡æ¡£

## ğŸ“‹ ç›®å½•

1. [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
2. [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
3. [æ ¸å¿ƒæ¨¡å—](#æ ¸å¿ƒæ¨¡å—)
4. [APIæ–‡æ¡£](#apiæ–‡æ¡£)
5. [æ•°æ®ç»“æ„](#æ•°æ®ç»“æ„)
6. [ç®—æ³•å®ç°](#ç®—æ³•å®ç°)
7. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
8. [å®‰å…¨æœºåˆ¶](#å®‰å…¨æœºåˆ¶)
9. [éƒ¨ç½²æŒ‡å—](#éƒ¨ç½²æŒ‡å—)
10. [å¼€å‘è§„èŒƒ](#å¼€å‘è§„èŒƒ)

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å‰ç«¯å±•ç¤ºå±‚                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚   Web UI    â”‚ â”‚  Mobile UI  â”‚ â”‚   PWA UI    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä¸šåŠ¡é€»è¾‘å±‚                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  å­¦ä¹ å¼•æ“   â”‚ â”‚  è¯„ä¼°å¼•æ“   â”‚ â”‚  æ¨èå¼•æ“   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  AIåŠ©æ‰‹     â”‚ â”‚  åä½œç³»ç»Ÿ   â”‚ â”‚  åˆ†æå¼•æ“   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ•°æ®è®¿é—®å±‚                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ IndexedDB   â”‚ â”‚ LocalStorageâ”‚ â”‚ SessionStorageâ”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  Cache API  â”‚ â”‚ Web Workers â”‚ â”‚ Service Workerâ”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¨¡å—ä¾èµ–å…³ç³»

```
app.js (ä¸»åº”ç”¨)
â”œâ”€â”€ levels.engine.js (å…³å¡å¼•æ“)
â”œâ”€â”€ scoring.js (è¯„åˆ†ç³»ç»Ÿ)
â”œâ”€â”€ analytics.dashboard.js (åˆ†æä»ªè¡¨æ¿)
â”œâ”€â”€ learning.path.js (å­¦ä¹ è·¯å¾„)
â”œâ”€â”€ ai.assistant.js (AIåŠ©æ‰‹)
â”œâ”€â”€ question.generator.js (é¢˜ç›®ç”Ÿæˆå™¨)
â”œâ”€â”€ collaborative.learning.js (åä½œå­¦ä¹ )
â”œâ”€â”€ assessment.engine.js (è¯„ä¼°å¼•æ“)
â”œâ”€â”€ content.recommender.js (å†…å®¹æ¨è)
â”œâ”€â”€ data.quality.checker.js (æ•°æ®è´¨é‡æ£€æŸ¥)
â”œâ”€â”€ performance.optimizer.js (æ€§èƒ½ä¼˜åŒ–)
â””â”€â”€ enhancements.js (ç•Œé¢å¢å¼º)
```

## ğŸ› ï¸ æŠ€æœ¯æ ˆ

### å‰ç«¯æŠ€æœ¯

**æ ¸å¿ƒæŠ€æœ¯**ï¼š
- **HTML5**: è¯­ä¹‰åŒ–æ ‡è®°ï¼Œæ”¯æŒç°ä»£Webæ ‡å‡†
- **CSS3**: ç°ä»£æ ·å¼ï¼Œæ”¯æŒGridã€Flexboxã€åŠ¨ç”»
- **JavaScript ES6+**: æ¨¡å—åŒ–å¼€å‘ï¼Œå¼‚æ­¥ç¼–ç¨‹
- **Web APIs**: ä¸°å¯Œçš„æµè§ˆå™¨APIæ”¯æŒ

**UI/UXæŠ€æœ¯**ï¼š
- **å“åº”å¼è®¾è®¡**: ç§»åŠ¨ä¼˜å…ˆï¼Œå¤šè®¾å¤‡é€‚é…
- **CSS Grid & Flexbox**: ç°ä»£å¸ƒå±€æŠ€æœ¯
- **CSSåŠ¨ç”»**: æµç•…çš„äº¤äº’åŠ¨æ•ˆ
- **Webå­—ä½“**: ä¼˜åŒ–çš„å­—ä½“åŠ è½½ç­–ç•¥

**æ€§èƒ½æŠ€æœ¯**ï¼š
- **Service Worker**: ç¦»çº¿æ”¯æŒï¼Œç¼“å­˜ç­–ç•¥
- **Web Workers**: åå°è®¡ç®—ï¼Œä¸é˜»å¡UI
- **IndexedDB**: å®¢æˆ·ç«¯æ•°æ®åº“å­˜å‚¨
- **Cache API**: æ™ºèƒ½ç¼“å­˜ç®¡ç†

### æ•°æ®æŠ€æœ¯

**å­˜å‚¨æ–¹æ¡ˆ**ï¼š
- **IndexedDB**: ç»“æ„åŒ–æ•°æ®å­˜å‚¨
- **LocalStorage**: ç”¨æˆ·åå¥½è®¾ç½®
- **SessionStorage**: ä¼šè¯ä¸´æ—¶æ•°æ®
- **Cache API**: èµ„æºæ–‡ä»¶ç¼“å­˜

**æ•°æ®æ ¼å¼**ï¼š
- **JSON**: é…ç½®å’Œæ•°æ®äº¤æ¢
- **CSV**: æ‰¹é‡æ•°æ®å¯¼å…¥å¯¼å‡º
- **Base64**: å›¾ç‰‡å’Œæ–‡ä»¶ç¼–ç 
- **Blob**: äºŒè¿›åˆ¶æ•°æ®å¤„ç†

### AI/MLæŠ€æœ¯

**ç®—æ³•å®ç°**ï¼š
- **ååŒè¿‡æ»¤**: ç”¨æˆ·è¡Œä¸ºåˆ†æ
- **å†…å®¹è¿‡æ»¤**: åŸºäºå†…å®¹çš„æ¨è
- **è‡ªç„¶è¯­è¨€å¤„ç†**: æ–‡æœ¬åˆ†æå’Œç†è§£
- **æœºå™¨å­¦ä¹ **: è‡ªé€‚åº”å­¦ä¹ ç®—æ³•

**æ•°æ®åˆ†æ**ï¼š
- **ç»Ÿè®¡åˆ†æ**: å­¦ä¹ æ•°æ®ç»Ÿè®¡
- **è¶‹åŠ¿åˆ†æ**: å­¦ä¹ è¿›åº¦è¶‹åŠ¿
- **èšç±»åˆ†æ**: ç”¨æˆ·ç¾¤ä½“åˆ†æ
- **é¢„æµ‹æ¨¡å‹**: å­¦ä¹ æ•ˆæœé¢„æµ‹

## ğŸ”§ æ ¸å¿ƒæ¨¡å—

### 1. å­¦ä¹ å¼•æ“ (levels.engine.js)

**åŠŸèƒ½æ¦‚è¿°**ï¼š
- åŠ¨æ€ç”Ÿæˆå­¦ä¹ å†…å®¹
- è‡ªé€‚åº”éš¾åº¦è°ƒæ•´
- å¤šè¯­è¨€æ”¯æŒ
- ç¦»çº¿å­¦ä¹ æ”¯æŒ

**æ ¸å¿ƒç±»å’Œæ–¹æ³•**ï¼š

```javascript
class LevelsEngine {
    // åˆå§‹åŒ–å¼•æ“
    constructor(config) {
        this.config = config;
        this.seeds = null;
        this.currentLevel = null;
    }
    
    // åŠ è½½ç§å­æ•°æ®
    async loadSeeds() {
        // ä»æœ¬åœ°æˆ–è¿œç¨‹åŠ è½½æ•°æ®
    }
    
    // ç”Ÿæˆå…³å¡å†…å®¹
    generateLevel(type, difficulty) {
        // æ ¹æ®ç±»å‹å’Œéš¾åº¦ç”Ÿæˆå†…å®¹
    }
    
    // æ‰©å±•æ ‡é¢˜å†…å®¹
    titleExpand(sample, materials) {
        // åŠ¨æ€ç”Ÿæˆæ ‡é¢˜ç»ƒä¹ 
    }
    
    // æ‰©å±•å›¾è¡¨å†…å®¹
    chartExpand(sample, materials) {
        // åŠ¨æ€ç”Ÿæˆå›¾è¡¨ç»ƒä¹ 
    }
}
```

**æ•°æ®æµç¨‹**ï¼š
```
ç§å­æ•°æ®åŠ è½½ â†’ å†…å®¹ç”Ÿæˆ â†’ éš¾åº¦è°ƒæ•´ â†’ ç”¨æˆ·äº¤äº’ â†’ ç»“æœè¯„ä¼°
```

### 2. è¯„åˆ†ç³»ç»Ÿ (scoring.js)

**è¯„åˆ†ç®—æ³•**ï¼š

```javascript
// æ ‡é¢˜è¯„åˆ†ç®—æ³•
function scoreTitle(title, materials) {
    const weights = {
        neutrality: 0.3,    // ä¸­æ€§åŒ–ç¨‹åº¦
        completeness: 0.25, // å®Œæ•´æ€§
        accuracy: 0.25,     // å‡†ç¡®æ€§
        clarity: 0.2        // æ¸…æ™°åº¦
    };
    
    let score = 0;
    
    // ä¸­æ€§åŒ–è¯„åˆ†
    score += weights.neutrality * calculateNeutrality(title);
    
    // å®Œæ•´æ€§è¯„åˆ†
    score += weights.completeness * calculateCompleteness(title, materials);
    
    // å‡†ç¡®æ€§è¯„åˆ†
    score += weights.accuracy * calculateAccuracy(title, materials);
    
    // æ¸…æ™°åº¦è¯„åˆ†
    score += weights.clarity * calculateClarity(title);
    
    return Math.round(score * 100);
}

// å›¾è¡¨è¯„åˆ†ç®—æ³•
function scoreChart(chart, materials) {
    const criteria = {
        dataAccuracy: 0.4,   // æ•°æ®å‡†ç¡®æ€§
        visualization: 0.3,  // å¯è§†åŒ–è´¨é‡
        clarity: 0.2,        // æ¸…æ™°åº¦
        ethics: 0.1          // ä¼¦ç†æ€§
    };
    
    // å®ç°å…·ä½“è¯„åˆ†é€»è¾‘
}
```

**è¯„åˆ†ç»´åº¦**ï¼š
- **å‡†ç¡®æ€§**: äº‹å®æ­£ç¡®æ€§ï¼Œæ•°æ®å‡†ç¡®æ€§
- **å®Œæ•´æ€§**: ä¿¡æ¯å®Œæ•´åº¦ï¼Œè¦ç´ é½å…¨æ€§
- **ä¸­æ€§åŒ–**: å®¢è§‚æ€§ï¼Œå»é™¤ä¸»è§‚è‰²å½©
- **ä¼¦ç†æ€§**: ä»·å€¼è§‚æ­£ç¡®æ€§ï¼Œç¤¾ä¼šè´£ä»»

### 3. AIåŠ©æ‰‹ (ai.assistant.js)

**æ ¸å¿ƒåŠŸèƒ½**ï¼š

```javascript
class AIAssistant {
    constructor() {
        this.knowledgeBase = new KnowledgeBase();
        this.nlpProcessor = new NLPProcessor();
        this.responseGenerator = new ResponseGenerator();
    }
    
    // å¤„ç†ç”¨æˆ·é—®é¢˜
    async processQuestion(question, context) {
        // 1. é—®é¢˜ç†è§£
        const intent = await this.nlpProcessor.analyzeIntent(question);
        
        // 2. çŸ¥è¯†æ£€ç´¢
        const knowledge = await this.knowledgeBase.search(intent);
        
        // 3. ç­”æ¡ˆç”Ÿæˆ
        const response = await this.responseGenerator.generate(
            question, knowledge, context
        );
        
        return response;
    }
    
    // å­¦ä¹ å»ºè®®ç”Ÿæˆ
    generateLearningAdvice(userProfile, learningHistory) {
        // åŸºäºç”¨æˆ·ç”»åƒå’Œå­¦ä¹ å†å²ç”Ÿæˆå»ºè®®
    }
}
```

**çŸ¥è¯†åº“ç»“æ„**ï¼š
```javascript
const knowledgeBase = {
    concepts: {
        "åª’ä½“ç´ å…»": {
            definition: "...",
            examples: [...],
            relatedConcepts: [...]
        }
    },
    skills: {
        "æ‰¹åˆ¤æ€§æ€ç»´": {
            description: "...",
            techniques: [...],
            exercises: [...]
        }
    },
    faqs: [
        {
            question: "...",
            answer: "...",
            tags: [...]
        }
    ]
};
```

### 4. æ¨èç³»ç»Ÿ (content.recommender.js)

**æ¨èç®—æ³•**ï¼š

```javascript
class RecommendationEngine {
    constructor() {
        this.collaborativeFilter = new CollaborativeFiltering();
        this.contentBasedFilter = new ContentBasedFiltering();
        this.hybridRecommender = new HybridRecommendation();
    }
    
    // ç”Ÿæˆæ¨è
    async generateRecommendations(userId, context) {
        // 1. ååŒè¿‡æ»¤æ¨è
        const collaborativeRecs = await this.collaborativeFilter
            .recommend(userId, context);
        
        // 2. åŸºäºå†…å®¹çš„æ¨è
        const contentBasedRecs = await this.contentBasedFilter
            .recommend(userId, context);
        
        // 3. æ··åˆæ¨è
        const hybridRecs = await this.hybridRecommender
            .combine(collaborativeRecs, contentBasedRecs);
        
        return hybridRecs;
    }
}

// ååŒè¿‡æ»¤ç®—æ³•
class CollaborativeFiltering {
    // è®¡ç®—ç”¨æˆ·ç›¸ä¼¼åº¦
    calculateUserSimilarity(user1, user2) {
        // ä½™å¼¦ç›¸ä¼¼åº¦è®¡ç®—
        const dotProduct = this.dotProduct(user1.vector, user2.vector);
        const magnitude1 = this.magnitude(user1.vector);
        const magnitude2 = this.magnitude(user2.vector);
        
        return dotProduct / (magnitude1 * magnitude2);
    }
    
    // ç”Ÿæˆæ¨è
    recommend(userId, k = 10) {
        // æ‰¾åˆ°ç›¸ä¼¼ç”¨æˆ·
        const similarUsers = this.findSimilarUsers(userId, k);
        
        // åŸºäºç›¸ä¼¼ç”¨æˆ·çš„åå¥½ç”Ÿæˆæ¨è
        return this.generateRecommendations(similarUsers);
    }
}
```

### 5. æ•°æ®è´¨é‡æ£€æŸ¥ (data.quality.checker.js)

**æ£€æŸ¥ç»´åº¦**ï¼š

```javascript
class DataQualityChecker {
    // ç»“æ„å®Œæ•´æ€§æ£€æŸ¥
    checkStructuralIntegrity(data) {
        const issues = [];
        
        // æ£€æŸ¥å¿…éœ€å­—æ®µ
        const requiredFields = ['id', 'type', 'content', 'metadata'];
        for (const field of requiredFields) {
            if (!data.hasOwnProperty(field)) {
                issues.push(`Missing required field: ${field}`);
            }
        }
        
        // æ£€æŸ¥æ•°æ®ç±»å‹
        if (typeof data.id !== 'string') {
            issues.push('ID must be a string');
        }
        
        return issues;
    }
    
    // å†…å®¹è´¨é‡æ£€æŸ¥
    checkContentQuality(content) {
        const issues = [];
        
        // æ£€æŸ¥å†…å®¹é•¿åº¦
        if (content.length < 10) {
            issues.push('Content too short');
        }
        
        // æ£€æŸ¥ç‰¹æ®Šå­—ç¬¦
        if (/[^\w\s\u4e00-\u9fff]/.test(content)) {
            issues.push('Contains invalid characters');
        }
        
        return issues;
    }
    
    // ä¸€è‡´æ€§æ£€æŸ¥
    checkConsistency(dataset) {
        // æ£€æŸ¥æ•°æ®é—´çš„ä¸€è‡´æ€§
    }
}
```

## ğŸ“Š æ•°æ®ç»“æ„

### ç”¨æˆ·æ•°æ®æ¨¡å‹

```javascript
const UserProfile = {
    id: "string",                    // ç”¨æˆ·å”¯ä¸€æ ‡è¯†
    name: "string",                  // ç”¨æˆ·å§“å
    email: "string",                 // é‚®ç®±åœ°å€
    avatar: "string",                // å¤´åƒURL
    preferences: {
        language: "zh-CN",           // è¯­è¨€åå¥½
        theme: "light",              // ä¸»é¢˜åå¥½
        difficulty: "medium",        // éš¾åº¦åå¥½
        notifications: true          // é€šçŸ¥è®¾ç½®
    },
    learningProfile: {
        level: 5,                    // å½“å‰ç­‰çº§
        experience: 1250,            // ç»éªŒå€¼
        skillLevels: {               // æŠ€èƒ½æ°´å¹³
            titleAnalysis: 7,
            chartAnalysis: 6,
            sourceVerification: 8,
            ethicsJudgment: 5,
            rumorDetection: 6,
            synthesis: 4
        },
        learningStyle: "visual",     // å­¦ä¹ é£æ ¼
        goals: ["improve_critical_thinking"] // å­¦ä¹ ç›®æ ‡
    },
    statistics: {
        totalStudyTime: 3600,        // æ€»å­¦ä¹ æ—¶é—´(ç§’)
        sessionsCompleted: 25,       // å®Œæˆçš„å­¦ä¹ ä¼šè¯
        averageScore: 78.5,          // å¹³å‡åˆ†æ•°
        streakDays: 7,               // è¿ç»­å­¦ä¹ å¤©æ•°
        lastActiveDate: "2024-12-20" // æœ€åæ´»è·ƒæ—¥æœŸ
    },
    achievements: [                  // æˆå°±åˆ—è¡¨
        {
            id: "first_perfect_score",
            name: "å®Œç¾è¡¨ç°",
            description: "é¦–æ¬¡è·å¾—æ»¡åˆ†",
            unlockedAt: "2024-12-15",
            icon: "ğŸ†"
        }
    ],
    createdAt: "2024-12-01T00:00:00Z",
    updatedAt: "2024-12-20T12:00:00Z"
};
```

### å­¦ä¹ å†…å®¹æ¨¡å‹

```javascript
const LearningContent = {
    id: "string",                    // å†…å®¹å”¯ä¸€æ ‡è¯†
    type: "title|chart|source|ethics|rumor|synthesis", // å†…å®¹ç±»å‹
    category: "string",              // åˆ†ç±»
    title: "string",                 // æ ‡é¢˜
    description: "string",           // æè¿°
    difficulty: 1-10,                // éš¾åº¦ç­‰çº§
    estimatedTime: 300,              // é¢„ä¼°å®Œæˆæ—¶é—´(ç§’)
    content: {
        prompt: "string",            // é¢˜ç›®æç¤º
        materials: {                 // å­¦ä¹ ææ–™
            text: "string",
            images: ["url1", "url2"],
            videos: ["url1"],
            charts: [{}]
        },
        questions: [                 // é—®é¢˜åˆ—è¡¨
            {
                id: "string",
                type: "single|multiple|text|essay",
                question: "string",
                options: ["A", "B", "C", "D"],
                correctAnswer: "A",
                explanation: "string",
                weight: 0.25
            }
        ],
        rubric: {                    // è¯„åˆ†æ ‡å‡†
            criteria: [
                {
                    name: "accuracy",
                    weight: 0.4,
                    description: "ç­”æ¡ˆå‡†ç¡®æ€§"
                }
            ]
        }
    },
    metadata: {
        tags: ["critical_thinking", "media_literacy"],
        author: "string",
        version: "1.0",
        language: "zh-CN",
        lastUpdated: "2024-12-20"
    },
    analytics: {
        viewCount: 150,              // æŸ¥çœ‹æ¬¡æ•°
        completionRate: 0.85,        // å®Œæˆç‡
        averageScore: 76.3,          // å¹³å‡åˆ†æ•°
        averageTime: 280,            // å¹³å‡å®Œæˆæ—¶é—´
        difficulty_rating: 6.5       // ç”¨æˆ·è¯„ä»·éš¾åº¦
    }
};
```

### å­¦ä¹ è®°å½•æ¨¡å‹

```javascript
const LearningRecord = {
    id: "string",                    // è®°å½•å”¯ä¸€æ ‡è¯†
    userId: "string",                // ç”¨æˆ·ID
    contentId: "string",             // å†…å®¹ID
    sessionId: "string",             // ä¼šè¯ID
    startTime: "2024-12-20T10:00:00Z", // å¼€å§‹æ—¶é—´
    endTime: "2024-12-20T10:15:00Z",   // ç»“æŸæ—¶é—´
    duration: 900,                   // å­¦ä¹ æ—¶é•¿(ç§’)
    status: "completed|in_progress|abandoned", // çŠ¶æ€
    score: {
        total: 85,                   // æ€»åˆ†
        breakdown: {                 // åˆ†é¡¹å¾—åˆ†
            accuracy: 90,
            completeness: 80,
            creativity: 85
        },
        percentile: 75               // ç™¾åˆ†ä½æ’å
    },
    answers: [                       // ç”¨æˆ·ç­”æ¡ˆ
        {
            questionId: "string",
            answer: "string|array",
            isCorrect: true,
            timeSpent: 60,
            attempts: 1
        }
    ],
    feedback: {
        strengths: ["é€»è¾‘æ¸…æ™°", "åˆ†ææ·±å…¥"],
        improvements: ["éœ€è¦æ›´å¤šç»†èŠ‚", "å¯ä»¥æ›´å®¢è§‚"],
        suggestions: ["å¤šç»ƒä¹ å›¾è¡¨åˆ†æ", "å…³æ³¨æ•°æ®æ¥æº"]
    },
    interactions: [                  // äº¤äº’è®°å½•
        {
            timestamp: "2024-12-20T10:05:00Z",
            action: "click_hint",
            target: "question_1",
            data: {}
        }
    ],
    context: {
        device: "desktop",           // è®¾å¤‡ç±»å‹
        browser: "Chrome",           // æµè§ˆå™¨
        screenSize: "1920x1080",     // å±å¹•å°ºå¯¸
        referrer: "dashboard"        // æ¥æºé¡µé¢
    }
};
```

## ğŸ§® ç®—æ³•å®ç°

### è‡ªé€‚åº”å­¦ä¹ ç®—æ³•

```javascript
class AdaptiveLearningAlgorithm {
    constructor() {
        this.difficultyModel = new DifficultyModel();
        this.performancePredictor = new PerformancePredictor();
    }
    
    // è®¡ç®—ä¸‹ä¸€é¢˜éš¾åº¦
    calculateNextDifficulty(userProfile, currentPerformance) {
        const currentLevel = userProfile.skillLevel;
        const recentPerformance = this.getRecentPerformance(userProfile);
        
        // åŸºäºIRTæ¨¡å‹è®¡ç®—
        const ability = this.estimateAbility(recentPerformance);
        const optimalDifficulty = this.findOptimalDifficulty(ability);
        
        // è€ƒè™‘å­¦ä¹ æ›²çº¿
        const adjustedDifficulty = this.adjustForLearningCurve(
            optimalDifficulty, currentPerformance
        );
        
        return Math.max(1, Math.min(10, adjustedDifficulty));
    }
    
    // ä¼°è®¡ç”¨æˆ·èƒ½åŠ›
    estimateAbility(performanceHistory) {
        // ä½¿ç”¨è´å¶æ–¯æ¨æ–­ä¼°è®¡èƒ½åŠ›å‚æ•°
        let ability = 0;
        let weight = 0;
        
        for (const record of performanceHistory) {
            const itemDifficulty = record.difficulty;
            const response = record.score / 100;
            
            // IRTæ¨¡å‹æ¦‚ç‡å‡½æ•°
            const probability = this.irtProbability(ability, itemDifficulty);
            
            // æ›´æ–°èƒ½åŠ›ä¼°è®¡
            const likelihood = response * probability + (1 - response) * (1 - probability);
            ability += Math.log(likelihood) * record.weight;
            weight += record.weight;
        }
        
        return weight > 0 ? ability / weight : 0;
    }
    
    // IRTæ¦‚ç‡å‡½æ•°
    irtProbability(ability, difficulty, discrimination = 1) {
        const exponent = discrimination * (ability - difficulty);
        return 1 / (1 + Math.exp(-exponent));
    }
}
```

### çŸ¥è¯†å›¾è°±æ„å»ºç®—æ³•

```javascript
class KnowledgeGraphBuilder {
    constructor() {
        this.concepts = new Map();
        this.relationships = new Map();
    }
    
    // æ„å»ºçŸ¥è¯†å›¾è°±
    buildGraph(learningContent) {
        // 1. æå–æ¦‚å¿µ
        const concepts = this.extractConcepts(learningContent);
        
        // 2. è¯†åˆ«å…³ç³»
        const relationships = this.identifyRelationships(concepts);
        
        // 3. æ„å»ºå›¾ç»“æ„
        const graph = this.constructGraph(concepts, relationships);
        
        return graph;
    }
    
    // æå–æ¦‚å¿µ
    extractConcepts(content) {
        const concepts = [];
        
        // ä½¿ç”¨NLPæŠ€æœ¯æå–å…³é”®æ¦‚å¿µ
        const keywords = this.extractKeywords(content.text);
        const entities = this.extractEntities(content.text);
        
        // åˆå¹¶å’Œå»é‡
        const allConcepts = [...keywords, ...entities];
        
        return this.deduplicateConcepts(allConcepts);
    }
    
    // è¯†åˆ«æ¦‚å¿µé—´å…³ç³»
    identifyRelationships(concepts) {
        const relationships = [];
        
        for (let i = 0; i < concepts.length; i++) {
            for (let j = i + 1; j < concepts.length; j++) {
                const relationship = this.analyzeRelationship(
                    concepts[i], concepts[j]
                );
                
                if (relationship.strength > 0.5) {
                    relationships.push(relationship);
                }
            }
        }
        
        return relationships;
    }
    
    // åˆ†ææ¦‚å¿µå…³ç³»
    analyzeRelationship(concept1, concept2) {
        // è®¡ç®—è¯­ä¹‰ç›¸ä¼¼åº¦
        const semanticSimilarity = this.calculateSemanticSimilarity(
            concept1, concept2
        );
        
        // è®¡ç®—å…±ç°é¢‘ç‡
        const cooccurrence = this.calculateCooccurrence(concept1, concept2);
        
        // ç»¼åˆè¯„åˆ†
        const strength = 0.6 * semanticSimilarity + 0.4 * cooccurrence;
        
        return {
            source: concept1,
            target: concept2,
            type: this.determineRelationType(concept1, concept2),
            strength: strength
        };
    }
}
```

### ä¸ªæ€§åŒ–æ¨èç®—æ³•

```javascript
class PersonalizedRecommendationEngine {
    constructor() {
        this.userEmbeddings = new Map();
        this.contentEmbeddings = new Map();
        this.interactionMatrix = new SparseMatrix();
    }
    
    // ç”Ÿæˆä¸ªæ€§åŒ–æ¨è
    async generateRecommendations(userId, numRecommendations = 10) {
        // 1. è·å–ç”¨æˆ·åµŒå…¥å‘é‡
        const userEmbedding = await this.getUserEmbedding(userId);
        
        // 2. è®¡ç®—å†…å®¹ç›¸ä¼¼åº¦
        const contentSimilarities = await this.calculateContentSimilarities(
            userEmbedding
        );
        
        // 3. åº”ç”¨ååŒè¿‡æ»¤
        const collaborativeScores = await this.applyCollaborativeFiltering(
            userId
        );
        
        // 4. æ··åˆæ¨èåˆ†æ•°
        const hybridScores = this.combineScores(
            contentSimilarities,
            collaborativeScores
        );
        
        // 5. æ’åºå’Œè¿‡æ»¤
        const recommendations = this.rankAndFilter(
            hybridScores,
            userId,
            numRecommendations
        );
        
        return recommendations;
    }
    
    // è®¡ç®—ç”¨æˆ·åµŒå…¥å‘é‡
    async getUserEmbedding(userId) {
        if (this.userEmbeddings.has(userId)) {
            return this.userEmbeddings.get(userId);
        }
        
        // åŸºäºç”¨æˆ·è¡Œä¸ºè®¡ç®—åµŒå…¥å‘é‡
        const userHistory = await this.getUserHistory(userId);
        const embedding = this.computeEmbeddingFromHistory(userHistory);
        
        this.userEmbeddings.set(userId, embedding);
        return embedding;
    }
    
    // åŸºäºå†å²è¡Œä¸ºè®¡ç®—åµŒå…¥å‘é‡
    computeEmbeddingFromHistory(history) {
        const embedding = new Array(128).fill(0); // 128ç»´å‘é‡
        
        for (const interaction of history) {
            const contentEmbedding = this.getContentEmbedding(
                interaction.contentId
            );
            const weight = this.calculateInteractionWeight(interaction);
            
            // åŠ æƒå¹³å‡
            for (let i = 0; i < embedding.length; i++) {
                embedding[i] += contentEmbedding[i] * weight;
            }
        }
        
        // å½’ä¸€åŒ–
        return this.normalizeVector(embedding);
    }
    
    // è®¡ç®—äº¤äº’æƒé‡
    calculateInteractionWeight(interaction) {
        let weight = 1.0;
        
        // åŸºäºäº¤äº’ç±»å‹
        const typeWeights = {
            'view': 1.0,
            'complete': 2.0,
            'like': 1.5,
            'share': 2.5,
            'comment': 3.0
        };
        weight *= typeWeights[interaction.type] || 1.0;
        
        // åŸºäºæ—¶é—´è¡°å‡
        const daysSince = (Date.now() - interaction.timestamp) / (1000 * 60 * 60 * 24);
        weight *= Math.exp(-daysSince / 30); // 30å¤©åŠè¡°æœŸ
        
        // åŸºäºè¯„åˆ†
        if (interaction.rating) {
            weight *= interaction.rating / 5.0;
        }
        
        return weight;
    }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–

### å‰ç«¯æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**1. èµ„æºåŠ è½½ä¼˜åŒ–**

```javascript
// æ‡’åŠ è½½å®ç°
class LazyLoader {
    constructor() {
        this.observer = new IntersectionObserver(
            this.handleIntersection.bind(this),
            { threshold: 0.1 }
        );
    }
    
    // è§‚å¯Ÿå…ƒç´ 
    observe(element) {
        this.observer.observe(element);
    }
    
    // å¤„ç†äº¤å‰äº‹ä»¶
    handleIntersection(entries) {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                this.loadContent(entry.target);
                this.observer.unobserve(entry.target);
            }
        });
    }
    
    // åŠ è½½å†…å®¹
    async loadContent(element) {
        const src = element.dataset.src;
        if (src) {
            try {
                const response = await fetch(src);
                const content = await response.text();
                element.innerHTML = content;
                element.classList.add('loaded');
            } catch (error) {
                console.error('Failed to load content:', error);
                element.classList.add('error');
            }
        }
    }
}

// é¢„åŠ è½½å…³é”®èµ„æº
class ResourcePreloader {
    constructor() {
        this.preloadQueue = [];
        this.loadedResources = new Set();
    }
    
    // é¢„åŠ è½½èµ„æº
    preload(url, type = 'fetch') {
        if (this.loadedResources.has(url)) {
            return Promise.resolve();
        }
        
        return new Promise((resolve, reject) => {
            const link = document.createElement('link');
            link.rel = 'preload';
            link.href = url;
            link.as = type;
            
            link.onload = () => {
                this.loadedResources.add(url);
                resolve();
            };
            
            link.onerror = reject;
            
            document.head.appendChild(link);
        });
    }
    
    // æ‰¹é‡é¢„åŠ è½½
    async preloadBatch(urls) {
        const promises = urls.map(url => this.preload(url));
        return Promise.allSettled(promises);
    }
}
```

**2. å†…å­˜ç®¡ç†ä¼˜åŒ–**

```javascript
// å†…å­˜æ± ç®¡ç†
class MemoryPool {
    constructor(createFn, resetFn, initialSize = 10) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.pool = [];
        this.inUse = new Set();
        
        // é¢„åˆ›å»ºå¯¹è±¡
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(this.createFn());
        }
    }
    
    // è·å–å¯¹è±¡
    acquire() {
        let obj;
        if (this.pool.length > 0) {
            obj = this.pool.pop();
        } else {
            obj = this.createFn();
        }
        
        this.inUse.add(obj);
        return obj;
    }
    
    // é‡Šæ”¾å¯¹è±¡
    release(obj) {
        if (this.inUse.has(obj)) {
            this.inUse.delete(obj);
            this.resetFn(obj);
            this.pool.push(obj);
        }
    }
    
    // æ¸…ç†æ± 
    cleanup() {
        this.pool.length = 0;
        this.inUse.clear();
    }
}

// å¼±å¼•ç”¨ç¼“å­˜
class WeakCache {
    constructor(maxSize = 100) {
        this.cache = new Map();
        this.maxSize = maxSize;
        this.accessOrder = [];
    }
    
    // è·å–ç¼“å­˜
    get(key) {
        if (this.cache.has(key)) {
            // æ›´æ–°è®¿é—®é¡ºåº
            this.updateAccessOrder(key);
            return this.cache.get(key);
        }
        return null;
    }
    
    // è®¾ç½®ç¼“å­˜
    set(key, value) {
        if (this.cache.size >= this.maxSize) {
            this.evictLRU();
        }
        
        this.cache.set(key, value);
        this.updateAccessOrder(key);
    }
    
    // æ›´æ–°è®¿é—®é¡ºåº
    updateAccessOrder(key) {
        const index = this.accessOrder.indexOf(key);
        if (index > -1) {
            this.accessOrder.splice(index, 1);
        }
        this.accessOrder.push(key);
    }
    
    // LRUæ·˜æ±°
    evictLRU() {
        const lruKey = this.accessOrder.shift();
        this.cache.delete(lruKey);
    }
}
```

**3. æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–**

```javascript
// è™šæ‹Ÿæ»šåŠ¨å®ç°
class VirtualScroller {
    constructor(container, itemHeight, renderItem) {
        this.container = container;
        this.itemHeight = itemHeight;
        this.renderItem = renderItem;
        this.data = [];
        this.visibleItems = [];
        this.scrollTop = 0;
        
        this.init();
    }
    
    init() {
        this.container.addEventListener('scroll', 
            this.throttle(this.handleScroll.bind(this), 16)
        );
        
        this.viewport = this.container.clientHeight;
        this.visibleCount = Math.ceil(this.viewport / this.itemHeight) + 2;
        
        this.render();
    }
    
    // å¤„ç†æ»šåŠ¨
    handleScroll() {
        this.scrollTop = this.container.scrollTop;
        this.render();
    }
    
    // æ¸²æŸ“å¯è§é¡¹
    render() {
        const startIndex = Math.floor(this.scrollTop / this.itemHeight);
        const endIndex = Math.min(
            startIndex + this.visibleCount,
            this.data.length
        );
        
        // æ¸…ç©ºå®¹å™¨
        this.container.innerHTML = '';
        
        // åˆ›å»ºå ä½ç©ºé—´
        const totalHeight = this.data.length * this.itemHeight;
        const offsetY = startIndex * this.itemHeight;
        
        const spacer = document.createElement('div');
        spacer.style.height = `${totalHeight}px`;
        spacer.style.position = 'relative';
        
        // æ¸²æŸ“å¯è§é¡¹
        for (let i = startIndex; i < endIndex; i++) {
            const item = this.renderItem(this.data[i], i);
            item.style.position = 'absolute';
            item.style.top = `${(i - startIndex) * this.itemHeight + offsetY}px`;
            item.style.height = `${this.itemHeight}px`;
            spacer.appendChild(item);
        }
        
        this.container.appendChild(spacer);
    }
    
    // èŠ‚æµå‡½æ•°
    throttle(func, delay) {
        let timeoutId;
        let lastExecTime = 0;
        
        return function (...args) {
            const currentTime = Date.now();
            
            if (currentTime - lastExecTime > delay) {
                func.apply(this, args);
                lastExecTime = currentTime;
            } else {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                    lastExecTime = Date.now();
                }, delay - (currentTime - lastExecTime));
            }
        };
    }
}
```

### æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–

```javascript
// IndexedDBä¼˜åŒ–å°è£…
class OptimizedIndexedDB {
    constructor(dbName, version = 1) {
        this.dbName = dbName;
        this.version = version;
        this.db = null;
        this.transactionPool = [];
    }
    
    // æ‰¹é‡æ“ä½œ
    async batchOperation(storeName, operations) {
        const transaction = this.db.transaction([storeName], 'readwrite');
        const store = transaction.objectStore(storeName);
        
        const promises = operations.map(op => {
            switch (op.type) {
                case 'add':
                    return store.add(op.data);
                case 'put':
                    return store.put(op.data);
                case 'delete':
                    return store.delete(op.key);
                default:
                    throw new Error(`Unknown operation type: ${op.type}`);
            }
        });
        
        await Promise.all(promises);
        return transaction.complete;
    }
    
    // ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
    async queryWithIndex(storeName, indexName, query, limit = 100) {
        const transaction = this.db.transaction([storeName], 'readonly');
        const store = transaction.objectStore(storeName);
        const index = store.index(indexName);
        
        const results = [];
        let cursor = await index.openCursor(query);
        let count = 0;
        
        while (cursor && count < limit) {
            results.push(cursor.value);
            cursor = await cursor.continue();
            count++;
        }
        
        return results;
    }
    
    // åˆ†é¡µæŸ¥è¯¢
    async paginatedQuery(storeName, pageSize = 50, lastKey = null) {
        const transaction = this.db.transaction([storeName], 'readonly');
        const store = transaction.objectStore(storeName);
        
        const range = lastKey ? 
            IDBKeyRange.lowerBound(lastKey, true) : 
            null;
        
        const results = [];
        let cursor = await store.openCursor(range);
        let count = 0;
        
        while (cursor && count < pageSize) {
            results.push(cursor.value);
            cursor = await cursor.continue();
            count++;
        }
        
        return {
            data: results,
            hasMore: count === pageSize,
            lastKey: results.length > 0 ? 
                results[results.length - 1].id : 
                null
        };
    }
}
```

## ğŸ”’ å®‰å…¨æœºåˆ¶

### æ•°æ®å®‰å…¨

```javascript
// æ•°æ®åŠ å¯†å·¥å…·
class DataEncryption {
    constructor() {
        this.algorithm = 'AES-GCM';
        this.keyLength = 256;
    }
    
    // ç”Ÿæˆå¯†é’¥
    async generateKey() {
        return await crypto.subtle.generateKey(
            {
                name: this.algorithm,
                length: this.keyLength
            },
            true,
            ['encrypt', 'decrypt']
        );
    }
    
    // åŠ å¯†æ•°æ®
    async encrypt(data, key) {
        const encoder = new TextEncoder();
        const dataBuffer = encoder.encode(JSON.stringify(data));
        
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        const encryptedData = await crypto.subtle.encrypt(
            {
                name: this.algorithm,
                iv: iv
            },
            key,
            dataBuffer
        );
        
        return {
            data: Array.from(new Uint8Array(encryptedData)),
            iv: Array.from(iv)
        };
    }
    
    // è§£å¯†æ•°æ®
    async decrypt(encryptedData, key) {
        const dataBuffer = new Uint8Array(encryptedData.data);
        const iv = new Uint8Array(encryptedData.iv);
        
        const decryptedData = await crypto.subtle.decrypt(
            {
                name: this.algorithm,
                iv: iv
            },
            key,
            dataBuffer
        );
        
        const decoder = new TextDecoder();
        const jsonString = decoder.decode(decryptedData);
        
        return JSON.parse(jsonString);
    }
}
```

### è¾“å…¥éªŒè¯

```javascript
// è¾“å…¥éªŒè¯å™¨
class InputValidator {
    constructor() {
        this.rules = new Map();
        this.sanitizers = new Map();
    }
    
    // æ·»åŠ éªŒè¯è§„åˆ™
    addRule(field, rule) {
        if (!this.rules.has(field)) {
            this.rules.set(field, []);
        }
        this.rules.get(field).push(rule);
    }
    
    // éªŒè¯æ•°æ®
    validate(data) {
        const errors = {};
        
        for (const [field, rules] of this.rules) {
            const value = data[field];
            
            for (const rule of rules) {
                const result = rule.validate(value);
                if (!result.valid) {
                    if (!errors[field]) {
                        errors[field] = [];
                    }
                    errors[field].push(result.message);
                }
            }
        }
        
        return {
            valid: Object.keys(errors).length === 0,
            errors: errors
        };
    }
    
    // æ¸…ç†æ•°æ®
    sanitize(data) {
        const sanitized = {};
        
        for (const [field, value] of Object.entries(data)) {
            if (this.sanitizers.has(field)) {
                sanitized[field] = this.sanitizers.get(field)(value);
            } else {
                sanitized[field] = this.defaultSanitize(value);
            }
        }
        
        return sanitized;
    }
    
    // é»˜è®¤æ¸…ç†
    defaultSanitize(value) {
        if (typeof value === 'string') {
            // ç§»é™¤HTMLæ ‡ç­¾
            value = value.replace(/<[^>]*>/g, '');
            // è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
            value = value.replace(/[<>&"']/g, char => {
                const entities = {
                    '<': '&lt;',
                    '>': '&gt;',
                    '&': '&amp;',
                    '"': '&quot;',
                    "'": '&#x27;'
                };
                return entities[char];
            });
        }
        
        return value;
    }
}

// å¸¸ç”¨éªŒè¯è§„åˆ™
const ValidationRules = {
    required: (message = 'Field is required') => ({
        validate: (value) => ({
            valid: value !== null && value !== undefined && value !== '',
            message: message
        })
    }),
    
    minLength: (min, message = `Minimum length is ${min}`) => ({
        validate: (value) => ({
            valid: typeof value === 'string' && value.length >= min,
            message: message
        })
    }),
    
    maxLength: (max, message = `Maximum length is ${max}`) => ({
        validate: (value) => ({
            valid: typeof value === 'string' && value.length <= max,
            message: message
        })
    }),
    
    email: (message = 'Invalid email format') => ({
        validate: (value) => {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return {
                valid: typeof value === 'string' && emailRegex.test(value),
                message: message
            };
        }
    }),
    
    numeric: (message = 'Must be a number') => ({
        validate: (value) => ({
            valid: !isNaN(value) && isFinite(value),
            message: message
        })
    })
};
```

## ğŸš€ éƒ¨ç½²æŒ‡å—

### ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

**1. æ„å»ºä¼˜åŒ–**

```bash
# å®‰è£…ä¾èµ–
npm install

# ä»£ç æ£€æŸ¥
npm run lint

# è¿è¡Œæµ‹è¯•
npm run test

# æ„å»ºç”Ÿäº§ç‰ˆæœ¬
npm run build

# å‹ç¼©èµ„æº
npm run compress
```

**2. æœåŠ¡å™¨é…ç½®**

```nginx
# Nginxé…ç½®ç¤ºä¾‹
server {
    listen 80;
    server_name your-domain.com;
    
    # é‡å®šå‘åˆ°HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    # SSLé…ç½®
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    
    # æ ¹ç›®å½•
    root /var/www/media-literacy-platform/dist;
    index index.html;
    
    # é™æ€èµ„æºç¼“å­˜
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header Vary Accept-Encoding;
        gzip_static on;
    }
    
    # HTMLæ–‡ä»¶ä¸ç¼“å­˜
    location ~* \.html$ {
        expires -1;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
    }
    
    # APIä»£ç†
    location /api/ {
        proxy_pass http://backend-server;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # SPAè·¯ç”±æ”¯æŒ
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    # å®‰å…¨å¤´
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https:;" always;
}
```

**3. CDNé…ç½®**

```javascript
// CDNèµ„æºé…ç½®
const CDN_CONFIG = {
    baseUrl: 'https://cdn.your-domain.com',
    resources: {
        js: '/js/',
        css: '/css/',
        images: '/images/',
        fonts: '/fonts/'
    },
    cacheTTL: {
        js: 31536000,      // 1å¹´
        css: 31536000,     // 1å¹´
        images: 2592000,   // 30å¤©
        fonts: 31536000    // 1å¹´
    }
};

// èµ„æºURLç”Ÿæˆå™¨
function getResourceUrl(type, filename) {
    const baseUrl = CDN_CONFIG.baseUrl;
    const path = CDN_CONFIG.resources[type];
    const version = process.env.VERSION || Date.now();
    
    return `${baseUrl}${path}${filename}?v=${version}`;
}
```

### ç›‘æ§å’Œæ—¥å¿—

```javascript
// æ€§èƒ½ç›‘æ§
class PerformanceMonitor {
    constructor() {
        this.metrics = new Map();
        this.observers = [];
        
        this.initObservers();
    }
    
    initObservers() {
        // é¡µé¢åŠ è½½æ€§èƒ½
        if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    this.recordMetric(entry.entryType, entry);
                }
            });
            
            observer.observe({ entryTypes: ['navigation', 'resource', 'measure'] });
            this.observers.push(observer);
        }
        
        // é•¿ä»»åŠ¡ç›‘æ§
        if ('PerformanceObserver' in window) {
            const longTaskObserver = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    this.recordLongTask(entry);
                }
            });
            
            longTaskObserver.observe({ entryTypes: ['longtask'] });
            this.observers.push(longTaskObserver);
        }
    }
    
    // è®°å½•æŒ‡æ ‡
    recordMetric(type, entry) {
        if (!this.metrics.has(type)) {
            this.metrics.set(type, []);
        }
        
        this.metrics.get(type).push({
            timestamp: Date.now(),
            ...entry
        });
        
        // å‘é€åˆ°ç›‘æ§æœåŠ¡
        this.sendToMonitoring(type, entry);
    }
    
    // å‘é€ç›‘æ§æ•°æ®
    async sendToMonitoring(type, data) {
        try {
            await fetch('/api/monitoring/metrics', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    type: type,
                    data: data,
                    timestamp: Date.now(),
                    userAgent: navigator.userAgent,
                    url: window.location.href
                })
            });
        } catch (error) {
            console.error('Failed to send monitoring data:', error);
        }
    }
}

// é”™è¯¯ç›‘æ§
class ErrorMonitor {
    constructor() {
        this.setupErrorHandlers();
    }
    
    setupErrorHandlers() {
        // JavaScripté”™è¯¯
        window.addEventListener('error', (event) => {
            this.reportError({
                type: 'javascript',
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack
            });
        });
        
        // Promiseæ‹’ç»
        window.addEventListener('unhandledrejection', (event) => {
            this.reportError({
                type: 'promise',
                message: event.reason?.message || 'Unhandled promise rejection',
                stack: event.reason?.stack
            });
        });
        
        // èµ„æºåŠ è½½é”™è¯¯
        window.addEventListener('error', (event) => {
            if (event.target !== window) {
                this.reportError({
                    type: 'resource',
                    message: `Failed to load ${event.target.tagName}`,
                    source: event.target.src || event.target.href
                });
            }
        }, true);
    }
    
    // æŠ¥å‘Šé”™è¯¯
    async reportError(error) {
        try {
            await fetch('/api/monitoring/errors', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ...error,
                    timestamp: Date.now(),
                    userAgent: navigator.userAgent,
                    url: window.location.href,
                    userId: this.getCurrentUserId()
                })
            });
        } catch (e) {
            console.error('Failed to report error:', e);
        }
    }
    
    getCurrentUserId() {
        // è·å–å½“å‰ç”¨æˆ·IDçš„é€»è¾‘
        return localStorage.getItem('userId') || 'anonymous';
    }
}
```

## ğŸ“ å¼€å‘è§„èŒƒ

### ä»£ç è§„èŒƒ

**1. JavaScriptè§„èŒƒ**

```javascript
// ä½¿ç”¨ES6+è¯­æ³•
const config = {
    apiUrl: 'https://api.example.com',
    timeout: 5000
};

// ä½¿ç”¨ç®­å¤´å‡½æ•°
const processData = (data) => {
    return data.map(item => ({
        ...item,
        processed: true
    }));
};

// ä½¿ç”¨async/await
async function fetchUserData(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        return userData;
    } catch (error) {
        console.error('Failed to fetch user data:', error);
        throw error;
    }
}

// ä½¿ç”¨è§£æ„èµ‹å€¼
const { name, email, preferences = {} } = user;

// ä½¿ç”¨æ¨¡æ¿å­—ç¬¦ä¸²
const message = `Welcome, ${name}! You have ${unreadCount} unread messages.`;
```

**2. CSSè§„èŒƒ**

```css
/* ä½¿ç”¨BEMå‘½åè§„èŒƒ */
.learning-module {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.learning-module__header {
    padding: 1rem;
    background-color: var(--primary-color);
    border-radius: 0.5rem 0.5rem 0 0;
}

.learning-module__title {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0;
}

.learning-module__content {
    padding: 1rem;
    flex: 1;
}

.learning-module__button {
    padding: 0.75rem 1.5rem;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.learning-module__button--disabled {
    background-color: var(--gray-400);
    cursor: not-allowed;
}

.learning-module__button:hover:not(.learning-module__button--disabled) {
    background-color: var(--accent-color-dark);
}

/* ä½¿ç”¨CSSè‡ªå®šä¹‰å±æ€§ */
:root {
    --primary-color: #3b82f6;
    --accent-color: #10b981;
    --accent-color-dark: #059669;
    --text-primary: #1f2937;
    --text-secondary: #6b7280;
    --gray-400: #9ca3af;
    --border-radius: 0.375rem;
    --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 768px) {
    .learning-module {
        margin: 0.5rem;
    }
    
    .learning-module__header {
        padding: 0.75rem;
    }
    
    .learning-module__title {
        font-size: 1.25rem;
    }
}
```

**3. æ–‡æ¡£è§„èŒƒ**

```javascript
/**
 * å­¦ä¹ å†…å®¹æ¨èå¼•æ“
 * 
 * @class ContentRecommender
 * @description åŸºäºç”¨æˆ·è¡Œä¸ºå’Œå†…å®¹ç‰¹å¾çš„æ™ºèƒ½æ¨èç³»ç»Ÿ
 * @author å¼€å‘å›¢é˜Ÿ
 * @version 1.0.0
 * @since 2024-12-20
 */
class ContentRecommender {
    /**
     * æ„é€ å‡½æ•°
     * 
     * @param {Object} config - é…ç½®å¯¹è±¡
     * @param {string} config.apiUrl - APIåŸºç¡€URL
     * @param {number} config.maxRecommendations - æœ€å¤§æ¨èæ•°é‡
     * @param {boolean} config.enableCaching - æ˜¯å¦å¯ç”¨ç¼“å­˜
     */
    constructor(config = {}) {
        this.config = {
            apiUrl: '/api',
            maxRecommendations: 10,
            enableCaching: true,
            ...config
        };
        
        this.cache = new Map();
        this.userProfile = null;
    }
    
    /**
     * ç”Ÿæˆä¸ªæ€§åŒ–æ¨è
     * 
     * @async
     * @param {string} userId - ç”¨æˆ·ID
     * @param {Object} options - æ¨èé€‰é¡¹
     * @param {string[]} options.categories - é™åˆ¶çš„åˆ†ç±»
     * @param {number} options.limit - æ¨èæ•°é‡é™åˆ¶
     * @param {boolean} options.includeViewed - æ˜¯å¦åŒ…å«å·²æŸ¥çœ‹å†…å®¹
     * @returns {Promise<Array>} æ¨èå†…å®¹åˆ—è¡¨
     * @throws {Error} å½“ç”¨æˆ·IDæ— æ•ˆæˆ–ç½‘ç»œé”™è¯¯æ—¶æŠ›å‡ºå¼‚å¸¸
     * 
     * @example
     * const recommender = new ContentRecommender();
     * const recommendations = await recommender.generateRecommendations('user123', {
     *     categories: ['title', 'chart'],
     *     limit: 5,
     *     includeViewed: false
     * });
     */
    async generateRecommendations(userId, options = {}) {
        // å®ç°é€»è¾‘...
    }
}
```

### Gitå·¥ä½œæµ

```bash
# åŠŸèƒ½å¼€å‘æµç¨‹
git checkout -b feature/new-recommendation-algorithm
git add .
git commit -m "feat: implement collaborative filtering algorithm"
git push origin feature/new-recommendation-algorithm

# æäº¤ä¿¡æ¯è§„èŒƒ
# feat: æ–°åŠŸèƒ½
# fix: ä¿®å¤bug
# docs: æ–‡æ¡£æ›´æ–°
# style: ä»£ç æ ¼å¼è°ƒæ•´
# refactor: ä»£ç é‡æ„
# test: æµ‹è¯•ç›¸å…³
# chore: æ„å»ºè¿‡ç¨‹æˆ–è¾…åŠ©å·¥å…·çš„å˜åŠ¨

# ä»£ç å®¡æŸ¥
git request-pull main origin/feature/new-recommendation-algorithm

# åˆå¹¶åˆ°ä¸»åˆ†æ”¯
git checkout main
git merge --no-ff feature/new-recommendation-algorithm
git tag -a v1.1.0 -m "Release version 1.1.0"
git push origin main --tags
```

---

*æŠ€æœ¯æ–‡æ¡£ç‰ˆæœ¬: v1.0 | æœ€åæ›´æ–°: 2024å¹´12æœˆ*